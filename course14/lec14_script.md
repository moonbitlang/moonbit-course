大家好，欢迎来到由IDEA研究院基础软件中心为大家带来的现代编程思想课。

今天我们给大家带来的是尝试实现一个简单的堆栈虚拟机，以月兔使用的后端Wasm为例。在第一部分中，我们将给大家介绍什么是堆栈虚拟机，以及我们所要实现的部分指令。

首先在解释虚拟机之前，先解释两个概念：编译与解释。大家都知道，我们所写下来的程序，都是文本格式。而电脑真正可以执行的，都是二进制格式。那么在其中，就会有一个编译的过程。编译，就是利用编译器，将源程序，通常可以说是源代码，转换为我们所要执行的目标程序。之后，我们便可以直接执行二进制格式的目标程序，在它的运行期间提供各类输入，比如命令行参数、命令行输入、或者是各类文件、网络资源，以此来获得我们所期望的输出。大家所熟悉的编译的语言可能就是`C`语言。但有的时候，对于一些语言，我们并不是直接编译后执行，而是直接将文本格式的源代码输入给解释器，让解释器一边读取程序，一边执行，以此获得我们想要的输出，典型的一般有JavaScript或者是Python。广义上来说，CPU也算是某种解释器。

这里延伸一下话题，感兴趣的同学可以搜索学习。事实上解释器与编译器并不是完全互相分离的两个概念。我们可以通过二村映射来将解释器转化为编译器。这里用到的概念是部分计算，这是一个程序优化的技术，那就是根据已知的信息，对运算进行特化。举个极端的例子来说，如果你的解释器是个计算器，你的程序是四则运算的表达式，那么完全可以利用这两个信息直接计算出程序所对应的值，以此获得一个目标程序。这个目标程序就等价于编译出的程序，只需要输入数据，即可获得输出程序。

那么在编译执行与解释执行之外，另一种方式是将两者结合起来。比较典型的是Java。Java的虚拟机是为了实现一处编写，处处运行这个目的而创建，定义了一个不基于任何平台的指令集，在不同的平台上再实现解释器，这样第一步是从源代码编译到这个虚拟指令集，之后解释器再对指令集进行解释执行。这里的解释器也就是虚拟机。常见的虚拟机有两种，一种是堆栈虚拟机，运算数存储在堆栈上，数据遵循先进后出原则。另一种则是寄存器虚拟机，与平时的计算机类似，运算数存储在一个个寄存器中。堆栈虚拟机实现较为简单，代码体积小，而寄存器虚拟机更贴近实际的计算机结构，性能更高。

寄存器虚拟机的一个例子就是Lua这个编程语言的虚拟机。在5.0版本以后，Lua采用了一个寄存器虚拟机。我们看一下以取最大值为例。我们假设输入在寄存器0和寄存器1，也就是`R(0)`和`R(1)`中，而结果将在`R(2)`中返回。我们首先假定返回结果为`R(0)`的值，利用MOVE指令，将寄存器0的值存到寄存器2中去。之后，如果`R(0)`比`R(1)`小，那么我们更新这个暂存的结果。我们在第二行利用`LT`指令，进行判断，并且将结果存入寄存器0中。第三行，跳转指令将根据寄存器0的值进行判断是否跳转。如果不跳转，那么就会执行下面的`MOVE`指令，将暂存的结果进行修改；如果跳转，那么这条指令会被跳过，直接到下方的返回结果的部分。这就是寄存器虚拟机，大家可以看到，参与计算的值都是存放在寄存器中，计算结束后也会返回寄存器中，一般指令后面都会有多个数字来指明寄存器。

堆栈虚拟机的一个例子就是月兔所使用的WebAssembly这个标准的虚拟机。我们同样以取最大值的函数为例。函数的参数被存放在`a`和`b`两个本地变量之中。如果要参与运算，我们需要将它们取到堆栈上，然后执行指令。例如第一行，同样是`a`赋值到`m`中，这里我们进行了一个取`a`和存`m`的操作，这个存取的对象就是一个堆栈。由比如下面第二行的比较操作，可以看到与之前不同，我们并没有声明对什么进行比较，这是因为我们默认对堆栈的最上方的两个元素进行比较操作。具体的运行我们稍后解释。

那么既然提到了WebAssembly，这里就对它进行一个简单的介绍。WebAssembly正如其名，Web+Assembly，是一个虚拟指令集，一开始是用于网络，可以在浏览器中使用，但是既然是指令集，那么只要实现虚拟机就可以在其他平台执行，因此也有Wasmtime、WAMR、WasmEdge等运行时。它也是MoonBit的第一个编译后端。它的一大特点在于它的指令集也有类型系统，因此安全性会有很大的保证。我们今天将会以WebAssembly指令集的子集为例。

我们今天的数据只考虑32位有符号整数，也就是月兔中的`Int`。考虑到控制流的需要，我们利用非零整数代表`true`，零代表`false`。我们的指令集包含：数据操作、数据存储、以及控制流。数据方面，`const`可以定义一个整数常数，还有加、减、相等判断与取模。数据存储则有从本地参数进行存取操作。控制流则有if else和函数调用。

在月兔中的定义基本上就是一比一复刻：数据利用一个枚举类型定义，虽然我们只有32位有符号整数；指令的话，就像刚才介绍的，有常数的定义、加减、取模、相等。还有函数的调用，本地的取值和设值，这里都利用字符串进行识别。最后则是条件判断，包含一个整数、两个指令列表。整数代表这个表达式块结束后将会有多少个计算结果，而两个指令列表分别对应条件为真的情况和条件为假的情况。

函数的类型定义则包含函数的名称、输入参数、输出参数以及本地变量和函数体。在这里，由于我们只有一个数据类型，因此我们只记录它们各自的名称，以及数量，而不考虑具体的对应的类型。一个完整的程序则包含多个函数，以及一个可选的函数作为程序入口。

之后我们来看一下堆栈虚拟机的具体的运转的过程。首先是数值计算。以`1+2`为例，我们有一个堆栈，初始为空。我们首先要做的是将数据添加到堆栈上。这里由于是常数，因此我们使用常数指令，添加`1`和`2`。之后，我们使用加法指令。加法指令将会取栈顶的两个值进行相加，并把结果存回栈顶。于是，我们运算完成后，堆栈栈顶元素是3。

除了直接使用常数指令进行定义，我们也可以利用本地变量。这些变量来自于函数的参数以及一些定义的临时变量。例如这里的加法，就会有参数`a`和`b`可供我们使用。我们利用获取指令，将对应的值分别存放到堆栈上，再进行运算。每一个本地变量都是可以修改的，可以通过`Set`指令进行。

之后我们还可以调用其他函数来进行计算。在这个例子中，我们利用加法函数进行计算。我们还是一样，先把`1`和`2`放到堆栈上。之后，我们调用函数。此时根据函数的参数数量，堆栈栈顶的对应数量的元素将被取出，依次绑定局部变量，同时在堆栈上会加入一个代表函数的元素。这个元素分隔开原来的堆栈数据与函数的数据，同时这个元素也会记录函数的返回值数量。之后我们在函数计算结束之后，根据返回值数量取出栈顶元素，将代表函数的元素移除后，再将栈顶元素放回栈顶，这样，我们就在调用函数的地方获得了运算的结果。

至于条件跳转，如我们之前所说，利用32位整数是否非零来代表真假值。当我们执行到`IF`语句时，我们取出栈顶元素，根据它的值进行判定，如果为真则执行`then`的分支，如果为假则执行`else`的分支。值得注意的是，Wasm的每一个代码块都具有参数类型和返回值类型，具体的就是指进入代码块时，参与运算的栈顶元素数量与类型，以及退出代码块时，相比原来的计算环境对栈顶元素进行的修改。比如这里，我们进入条件判断的代码块时并没有任何的输入，因此我们在`IF`代码块内执行运算时都假设堆栈为空，无论堆栈上原来有什么都与当前代码块无关。而我们声明了返回一个整数，因此我们在正常执行结束的时候，在当前计算环境中必须有且仅有一个整数。

我们利用刚才所描述的内容实现一个加法程序。加法函数的定义刚才已经见过了，我们添加了一个`test_add`用来作为程序的主入口。唯一需要注意的地方是我们在调用完`add`函数以后再次调用了`print_int`函数。`print_int`是一个特殊的函数。大家刚才可能注意到，我并没有提及如何在Wasm中定义输入与输出，那是因为这些功能需要外部函数来实现，Wasm本身可以认为是一个在沙盒中运行的程序

最后，我们会展示一下我们所希望获得的目标程序。大家可以对比一下我们之前月兔中定义的程序，会发现几乎是一一对应的。接下来我们要做的就是写一个编译器。这里的编译器比较简单，因为我们的数据定义一比一复刻了Wasm指令。我们所需要做的就是进行字符串的转换。需要注意的是，我在实现编译器的时候，我们这里并不直接利用字符串的拼接，而是采用对`Buffer`进行修改的方式。`Buffer`会额外分配一定的内存，因此当添加新的内容时，不一定需要额外分配一定的内存，相比简单的字符串的拼接而言，内存的分配操作可以减少。就像示例代码中，我们直接往`buffer`中添加字符串。当然，Wasm也不仅仅是有文本格式，它也有二进制格式。现在给大家展示的就是每个指令对应的二进制。感兴趣的可以查看WebAssembly的标准文档。

回想前几节课中，我们介绍了语法解析器。我们当时利用它解析了整数的加减乘除，并进行了计算。当时的例子比较简单，仅仅是加减乘除，完全可以进行常数折叠，也就是在编译的时候直接计算完成。但对于一个程序而言，整个常数折叠显然不是常态，都要编译到一个后端进行运行。那么在介绍了WebAssembly以后，我们就可以补上最后一块拼图。我们从字符串开始，进行词法分析，获得了单词流。之后我们利用语法解析器获得一个抽象语法树。从这一步开始，我们编译到WebAssembly指令集。最后，我们可以喂给各类运行时进行运行。当然，由于我们上节课介绍过的`Tagless Final`技巧，抽象语法树也可以省略也不一定。这里回想一下上节课的语法书，包含一个整数、加减乘除。

那么我们可以利用一个简单的递归函数。这个函数对于抽象语法树进行模式匹配，并翻译为对应的WebAssembly指令序列。例如，整数就翻译为单个常数指令，而加法等则需要通过递归的方式对两个参数进行翻译。之后，由于WebAssembly是堆栈虚拟机，因此我们将它们串联起来，并在最后添加加法指令。可以看到，我们这里也利用了月兔的运算符重载功能。

介绍完了编译，我们再来看看解释。我们这里构建一个解释器，来直接解释我们之前的程序。为了执行，我们需要有两个数据结构：一个操作数堆栈，和一个指令队列。在操作数栈上，除了存放参与运算的数值，就像之前标准定义的那样，我们也会存放函数运行前环境中存储的变量。而指令队列则存储着当前执行的指令。我们在原有的指令基础上进行拓展，添加一些控制指令，例如函数结束时的返回。

现在大家看到的就是我们的类型定义。拓展指令时，我们的函数结束指令有一个整数参数。这里指的实际上是函数的返回值的信息。由于我们这里只有整数，因此我们只存储最后返回几个数值。整个程序的环境就包含程序的定义，以及操作数栈、指令队列，以及当前计算环境下的本地变量。所有的数据结构都是不可变的，我们所需要做的就是根据上一个状态，包括当前要执行的指令等，计算出下一个状态。由于可能出错，毕竟我们没有验证代码，因此返回的状态是用`Option`定义的。

之后我们实现我们的解释器。我们要做的就是根据当前的指令与数据堆栈进行模式匹配。如果匹配成功，就像这里的加法指令，应当有连续两个整数在栈顶，那么我们计算出下一个状态。如果全部匹配都失败了，那么说明哪里出错了，我们就利用通配符直接返回`None`。

而对于条件判断，我们需要根据堆栈取出对应分支的代码加入指令队列中。需要注意的是，存储的指令都是未经过拓展的，因此我们这里进行一次映射。

接下来是对于函数调用。我们之前提到，在没有外部接口的情况下，WebAssembly只能默默进行计算，并不能进行输入输出，除非利用内存，当然那是另外的话题了。为了这个问题，我们在这里对于名称为`print_int`的函数进行特判，如果发现调用，我们直接将它的值输出到我们的缓存当中去。

而对于普通的函数调用，我们需要对当前的环境进行一个保存，然后进入到被调用的环境中去。指令方面，我们需要添加一个函数返回指令，然后在上方展开从程序中找到的对应的函数的指令。数据方面，我们要根据函数的参数数量，从当前的堆栈栈顶取下特定数量的元素，成为新的函数调用的环境。之后，我们在堆栈上添加了一个函数栈，这里面存放着目前的环境变量。

在执行完毕后，理论上此时应该是遇到返回函数的控制指令。我们根据指令中存储的返回值数量从栈顶取出元素，清空当前的计算环境，直到之前存放的函数栈。我们从中还原本来的计算环境，然后再接着进行计算。

那么以上便是本节课介绍的解释器。感兴趣的同学可以根据我们的指令集，在语法解析器中拓展函数的定义。或者也可以在指令集中添加提前返回指令`return`。